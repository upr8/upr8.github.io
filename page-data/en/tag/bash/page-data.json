{"componentChunkName":"component---src-templates-tag-tsx","path":"/en/tag/bash/","result":{"data":{"allMdx":{"totalCount":1,"edges":[{"node":{"body":"\n## Table of contents\n\n```toc\n# This code block gets replaced with the TOC\n```\n\n## Performance evaluation\n\n### Runtime\n\nOne of the methods for scpecifying the runtime of an application (Program?) is to use SECONDS valriable.\n\n```bash\nSECONDS=0; sleep 3; echo $SECONDS;\n```\n\n## Condition\n\n### Conditional structure\n\nThe general structure of a conditional statement in Bash is as follows:\n\n```bash\nval=14\nif test $val -eq 14 ; then\n    echo \"exit value of a command\"\nelif (( $val + 6 > 20 )); then\n    echo \"Mathematical expressions\"\nelif [ $val -gt 10 ] ; then\n    echo \"single bracket (POSIX standard)\"\nelif [[ $val -gt 10 ]]; then\n    echo \"double bracket (Bash and some others)\"\nelse\n    echo \"else condition\"\nfi\n```\n\n### Comparison conditions\n\n#### File Operators \nThe conditional operators for checking the status of files are visible in the table below:\n\n| Operator | Example | Description |\n|:--------:|:--------|:------------|\n| `-e`     | `-e $fileName`      | Checks if a file exists.                           |\n| `-d`     | `-d $directoryName` | Checks if a file exists and it is a directory.     |\n| `-f`     | `-f $fileName`      | Checks if a file exists and it is a regular file.  |\n| `-h`     | `-h $linkName`      | Checks if a file exists and it is a symbolic link. |\n| `-r`     | `-r $fileName`      | Checks if a file is readable.                      |\n| `-W`     | `-W $fileName`      | Checks if a file is writable.                      |\n| `-X`     | `-X $fileName`      | Checks if a file is executable.                    |\n| `-s`     | `-S $fileName`      | Checks if size of a file is non-zero.              |\n\n#### String Operators \nConditional operators for comparing strings is visible in the table below:\n\n| Operator | Example  | Description |\n| :------: | :------: | :--------------------- |\n| `-z` | `-z $str`        | Check if the length of the string is zero. |\n| `-n` | `-n $str`        | Check if the length of the string is not zero.|\n| `==` | `$str1 == $str2` | Check if the two strings are the same.|\n| `!=` | `$str1 != $str2` | Check if the two strings are not the same.|\n| `>`  | `$str1 > $str2`  | Check if str1 is lexicographically greater than str2. |\n| `<`  | `$str1 < $str2`  | Check if str1 is lexicographically less than str2. |\n\n#### Arithmatic Operators \nArithmatic comparisons can be performed using the following operators:\n\n| Operator | Example |  Description |\n| :------: | :-----: | :------------------------------- |\n| `-eq`    | `$int1 -eq $int2` |           Check if int1 and int2 are equal. |\n| `-ne`    | `$int1 -ne $int2` |         Check if int1 and int2 are not equal. |\n| `-gt`    | `$int1 -gt $int2` |  Check if int1 is greater than int2.|\n| `-ge`    | `$int1 -ge $int2` |  Check if int1 is greater than or equal to int2.|\n| `-lt`    | `$int1 -lt $int2` |     Check if int1 is less than int2. |\n| `-le`    | `$int1 -le $int2` | Check if int1 is less than or equal to int2. |\n\n\n### Conditional execution\n\nIf execution of the first command was successfull, the second command will be executed:\n\n```bash\ntrue && echo \"this message should show\"\n```\n\nIf a command encounters an error, another command will be executed:\n\n```bash\nfalse || echo \"this message should show\"\n```\n\nIf the previous command or function returned an error code, the next command will be executed:\n\n```bash\nfalse\n[[ $? -ne 0 ]] && echo \"this message should show\"\n```\n\n## Loops\n\nThe following two loops have the same functionality:\n\n```bash\nfor i in `seq 1 10`\ndo\n    echo \"\\$i is $i\"\ndone\n\nfor s in foo bar baz\ndo\n    echo $s\ndone\n\nfor (( i = 0; i < 10; i++ ))\ndo\n    echo \"\\$i is $i\"\ndone\n```\n\n## Working with arrays\n\n```bash\narray=(zero one two three)\necho \"${array[0]}\"          # shows the first element\necho \"${array[-1]}\"         # shows the last element\necho \"${array[@]}\"          # shows all elements\necho \"${array[@]:1:2}\"      # shows two elements (:2), starting from element with index of 1 (which is the 2nd element (:1))\narray[4]='fifth element'    # inserts an element at index 4\necho \"${array[4]}\"\narray+=('sixth')            # appends an element to array\nunset -v 'array[2]'         # deletes element with index of 2 from array\narray=(\"${array[@]}\")       # re-indexing an array\necho \"${#array[@]}\"         # shows the length of array\n```\n\nTo add an element to index 3 of an array, use the following code:\n\n```bash\narray=(\"${array[@]:0:2}\" '2.5' \"${array[@]:2}\")\necho \"${array[2]}\" #output: new\necho \"${array[@]}\"\n```\nExtract an array from a string(?):\n\n```bash\ntheStr=\"Zero,One,Two\"\narray=(${theStr//,/ })\necho ${array[0]}\necho ${array[2]}\n```\n\nReading elements of an array:\n\n```bash\narray=(1 2 3 4)\n# foreach loop\nfor y in \"${array[@]}\"; do\n    # act on $y\n    echo \"$y\"\ndone\n\n# for loop with index\nfor ((idx=0; idx < ${#array[@]}; ++idx)); do\n    # act on ${array[$idx]}\n    echo \"${array[$idx]}\"\ndone\n```\n\nRecieving the output of a command as an array, and then reading that array using Foreach loop(?):\n\n```bash\narray=($(tr ',' ' ' <<<\"0,1,2,3,4\"))\nfor y in \"${array[@]}\"; do\n    echo \"$y\"\ndone\n```\n\nFilling an array based on the output of a command:\n\n```bash\nwhile read -r; do\n    #array+=(\"$REPLY\")     # Array append\n    array[$i]=\"$REPLY\"     # Assignment by index\n    let i++                # Increment index\ndone < <(seq 1 10)  # command substitution\necho ${array[@]}    # output: 1 2 3 4 5 6 7 8 9 10\n```\n\n## Working with Map (Associative Array)\n\nThe first step is to create a _map_(?):\n\n```bash\ndeclare -A mp       # declare (This line is mandatory)\nmp[hello]=world     # insert\nmp[\"a long key\"]=v  # insert with a long key\necho ${mp[hello]}   # access\necho \"${!mp[@]}\"    # access all keys\necho \"${mp[@]}\"     # access all values\necho \"${#mp[@]}\"    # count of elements in a map\n\nfor key in \"${!mp[@]}\"; do # Iterate Over map\n    echo \"Key:   ${key}\"\n    echo \"Value: ${mp[$key]}\"\ndone\n\nunset mp            # destroy a map/array\n```\n\n## working with file:\n\nReading a file line by line and converting it into an array:\n\n```bash\nIFS=$'\\n' read -r -a arr < file\n```\n\nReading an entire file until reaching an empty line:\n\n```bash\nwhile read line || [ -n \"$line\" ]; do\n    echo $line\ndone < file\n```\n\n## Processing input parameters\n\nIf no parameter is passed to _for_ loop, it will be executed on the input file. \nThe following two loops have the same results:\n\n```bash\nfor arg; do\n    echo arg=$arg\ndone\n\nfor arg in \"$@\"; do\n    echo arg=$arg\ndone\n```\n\nThe following code from [stackoverflow](https://stackoverflow.com/a/16496491) demonstrates various\nuse casess for utilizing _getopts_ for processing input parameters:\n\n```bash\n#!/bin/bash\nusage() { echo \"Usage: $0 [-s <45|90>] [-p <string>]\" 1>&2; exit 1; }\n\nwhile getopts \":s:p:\" o; do\n    case \"${o}\" in\n        s)\n            s=${OPTARG}\n            ((s == 45 || s == 90)) || usage\n            ;;\n        p)\n            p=${OPTARG}\n            ;;\n        *)\n            usage\n            ;;\n    esac\ndone\nshift $((OPTIND-1))\n\nif [ -z \"${s}\" ] || [ -z \"${p}\" ]; then\n    usage\nfi\n```\n"}}]}},"pageContext":{"lang":"en","tag":"bash","title":"\"bash\"","desc":"List of content tagged with \"bash\"","slug":"/en/tag/bash"}},"staticQueryHashes":["768871489"],"slicesMap":{}}